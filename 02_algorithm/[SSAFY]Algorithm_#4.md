# [SSAFY]Algorithm_#4(written by wally-wally)

------

**※참고사항※**

- `[SSAFY]Algorithm_#4`는 정규과정 `Algorithm`을 진행한 내용들을 작성함.
- 최대한 수업 시간의 모든 내용을 담으려했으나 없는 내용이 있을 수도 있음.

------

<br>

## 21. 10월07일(28일차) - `DP`, `Computational Thinking`

### 21.1 동적 프로그래밍(DP) = `Recursive` + `Memoization`

#### (1) 동적 프로그래밍의 개념

- 큰 문제의 해답에 작은 문제의 해답이 포함되어 있고 이를 재귀 호출 알고리즘으로 구현하면 지나친 중복이 발생하는 경우 이 <b>재귀적 중복을 해결</b>하는 방법
- 어떤 문제가 여러 단계의 반복되는 부분 문제로 이루어질 때, <b>각 단계에 있는 부분 문제의 답을 기반으로 전체 문제의 답을 구하는 방법</b>
- 작은 문제들의 해를 먼저 구하여 저장하고 더 큰 문제의 해를 구할 때 <u><b>작은 문제의 해를 반복 계산하지 않고 저장된 결과를 사용하는 방법</b></u>

- 동적 프로그래밍 문제를 해결할 때 <b>`점화식`</b>을 찾자!

<br>

#### (2) 메모이제이션(Memoization)

- 컴퓨터 프로그램을 실행할 때 이전에 계산한 값을 메모리에 저장해서 매번 다시 계산하지 않도록 하여 전체적인 실행속도를 빠르게 하는 기술이다.
- 동적 계획법의 핵심이 되는 기술이다.

<br>

#### (3) 피보나치 수열

> `재귀함수`로 구현
>
> ```python
> import time
> start = time.time()
> 
> def fibo(n):
>     global cnt
>     cnt += 1
>     if n < 2:
>         return n
>     else:
>         return fibo(n - 1) + fibo(n - 2)
> 
> cnt = 0 # 호출횟수 변수
> N = int(input())
> print('피보나치 결과: ', fibo(N))
> print('호출횟수: ', cnt)
> print('수행시간: {}[ms]'.format(round(time.time() - start, 6)*1000))
> ```
>
> - `N = 30`일 때 피보나치 함수 수행 결과
>
> ```
> 피보나치 결과:  832040
> 호출횟수:  2692537
> 수행시간: 355.666[ms]
> ```

> `동적 프로그래밍`으로 구현(Memoization 방법 적용)
>
> - 피보나치 수를 구하는 알고리즘에서 `fibo(n)`의 값을 계산하자마자 저장하면(memoize), 실행시간을 `O(n)`으로 줄일 수 있다.
>
> ```python
> import time
> start = time.time()
> 
> def fibo(n):
>     global cnt
>     cnt += 1
>     if n >= 2 and memo[n] == -1:
>         memo[n] = fibo(n - 1) + fibo(n - 2)
>     return memo[n]
> 
> N = int(input())
> memo = [-1] * (N + 1)
> memo[0], memo[1] = 0, 1
> cnt = 0
> print('피보나치 결과: ', fibo(N))
> print('호출횟수: ', cnt)
> print('수행시간: {}[ms]'.format(round(time.time() - start, 6)*1000))
> ```
>
> - `N = 30`일 때 피보나치 함수 수행 결과
>
> ```
> 피보나치 결과:  832040
> 호출횟수:  59
> 수행시간: 0.0[ms]
> ```

> for문을 이용한 `DP로 피보나치 함수 구현하기`
>
> ```python
> def fibo(n):
>     # base case
>     if n == 0 or n == 1:
>         return n
>     memo[0], memo[1] = 0, 1
>     for i in range(2, n + 1):
>         memo[i] = memo[i - 1] + memo[i - 2]
>     return memo[n]
>     
> 
> for _ in range(int(input())):
>     N = int(input())
>     memo = [0] * (N + 1)
>     print(fibo(N))
> ```

<br>

### 21.2 논리 연습(명제) <a href="https://imnt.tistory.com/92" target="_blank">(진리표 참고)</a>

- `p ∧ q` 진리표

  | p    | q    | p ∧ q |
  | ---- | ---- | ----- |
  | T    | T    | T     |
  | T    | F    | F     |
  | F    | T    | F     |
  | F    | F    | F     |

- `p ∨ q` 진리표

  | p    | q    | p ∨ q |
  | ---- | ---- | ----- |
  | T    | T    | T     |
  | T    | F    | T     |
  | F    | T    | T     |
  | F    | F    | F     |

- `p → q` 진리표

  | p    | q    | p → q |
  | ---- | ---- | ----- |
  | T    | T    | T     |
  | T    | T    | F     |
  | F    | F    | T     |
  | F    | F    | T     |

- 명제의 역, 이, 대우 (그림 출처 : <a href="https://lypicfa.tistory.com/329" target="_blank">(바로 이동)</a>)

  <img src="https://user-images.githubusercontent.com/52685250/66294424-e95faf00-e923-11e9-8585-c17c51445071.gif" alt="명제의 역 이 대우" width = "500px">

<br>

### 21.3 증명

#### (1) 직접 증명

---

##### :one: n이 홀수이면 n<sup>2</sup> + n은 짝수임을 증명하라.

- <b>n = 2k + 1(2k - 1로 해도 무방함)</b>이라고 하면 n<sup>2</sup> + n = (2k + 1)<sup>2</sup> + (2k + 1) = 4k<sup>2</sup> + 4k + 1 + 2k + 1 = 4k<sup>2</sup> + 6k + 2가 된다.
- 이 식을 2로 묶으면 n = 2(2k<sup>2</sup> + 3k + 1)이 되므로 <b>n = 2×P</b>(P는 상수 또는 수식)라는 짝수형태 꼴로 나타낼 수 있다.
- 그러므로 n이 홀수이면 n<sup>2</sup> + n은 짝수임이 성립된다.

<br>

##### :two: m이 짝수이고 n이 홀수이면 2m+3n은 홀수임을 증명하라.

- <b>m = 2k, n = 2s + 1</b>이라고 하면 2m + 3n = 2(2k) + 3(2s + 1) = 4k + 6s + 3
- 2로 묶어 정리하면 n = 2(2k + 3s + 1) + 1이 되므로 <b>n = 2 × P + 1</b> 이라는 홀수형태 꼴로 나타낼 수 있다.
- 그러므로 m이 짝수이고 n이 홀수이면 2m+3n은 홀수임이 성립된다.

---

<br>

#### (2) 대우 증명

---

##### :one: 자연수 n에 대해, n<sup>2</sup> + 5가 홀수이면 n은 짝수임을 증명하라.

- 대우 증명법은 간접 증명법에 해당된다.
- 대우 : <b>n이 홀수이면 n<sup>2</sup> + 5는 짝수이다.</b>
- n = 2k + 1 => n<sup>2</sup> + 5= (2k + 1)<sup>2</sup> + 5 = 4k<sup>2</sup> + 4k + 6 = 2(2k<sup>2</sup> + 2k + 3) 이므로 n = 2×P 와 같은 짝수형태 꼴이므로 자연수 m에 대해, n<sup>2</sup> + 5가 홀수이면 n은 짝수임이 성립된다.

<br>

##### :two: n<sup>2</sup>이 짝수이면 n은 짝수임을 증명하라.

- 대우 : n이 홀수이면 n<sup>2</sup>은 홀수이다.
- n = 2k + 1이라고 하면, n<sup>2</sup> = (2k + 1)<sup>2</sup>  = 4k<sup>2</sup> + 4k + 1 = 2(2k<sup>2</sup> + 2k) + 1이므로 n = 2 × P + 1 이라는 홀수형태의 꼴로 나타낼 수 있다.
- 그러므로 n<sup>2</sup>이 짝수이면 n은 짝수임이 성립된다.

---

<br>

#### (3) 경우를 나누어 증명

---

##### :one: 자연수 n에 대해 n<sup>2</sup> + 5n + 3은 항상 홀수임을 증명하라.

- n이 짝수인 경우
  - n = 2k이라고 하면 4k<sup>2</sup> + 10k + 3 = 2(2k<sup>2</sup> + 5k + 1) + 1이므로 n = 2P + 1과 같은 홀수형태의 꼴로 나타낼 수 있다.
- n이 홀수인 경우
  - n = 2k + 1이라고 하면 (2k + 1)<sup>2</sup> + 5(2k + 1) + 3 = 4k<sup>2</sup> + 4k + 1 + 10k + 5 + 3 = 4k<sup>2</sup> + 14k + 9
  - 이는 2(2k<sup>2</sup> + 7k + 4) + 1로 n = 2P + 1과 같은 홀수형태의 꼴로 나타낼 수 있다.
- n이 짝수, 홀수 구분없이 n<sup>2</sup> + 5n + 3은 항상 홀수이므로 주어진 명제는 항상 성립된다.

<br>

##### :two:n이 홀수이면 n<sup>2</sup>을 8로 나눈 나머지는 1 임을 증명하라.

- n이 홀수일 때, n = 4k + 1, n = 4k + 3과 같이 두 가지 경우가 존재한다.

- n을 4로 나눈 나머지가 1인 경우
  - n = 4k + 1이라고 하면 (4k + 1)<sup>2</sup> = 8(2k<sup>2</sup> + k) + <b>1</b> => `홀수`인 형태가 됨.
- n을 4로 나눈 나머지가 3인 경우
  - n = 4k + 3이라고 하면 (4k + 3)<sup>2</sup> = 8(2k<sup>2</sup> + 3k + 1) + <b>1</b> = > `홀수`인 형태가 됨.
- 따라서 두 경우 모두 n = 8P + 1꼴이므로 n<sup>2</sup>을 8로 나눈 나머지는 1이 된다.
- 그러므로 n이 홀수이면 n<sup>2</sup>을 8로 나눈 나머지는 1 임이 성립된다.

<br>

##### :three: 어떤 자연수를 제곱하여도 그 결과를 3으로 나눈 나머지는 2가 아님을 증명하라.

- 어떤 자연수 n을 3k, 3k + 1, 3k + 2의 경우로 나누어 생각하자.
- n = 3k인 경우
  - n<sup>2</sup> = (3k)<sup>2</sup> = 9k<sup>2</sup> = 3(3k<sup>2</sup>) 이므로 3으로 나눈 나머지는 0이 된다.
- n = 3k + 1인 경우
  - n<sup>2</sup> = (3k + 1)<sup>2</sup> = 9k<sup>2</sup> + 6k + 1 = 3(3k<sup>2</sup> + 2k) + 1이므로 3으로 나눈 나머지는 1이 된다.
- n = 3k + 2인 경우
  - n<sup>2</sup> = (3k + 2)<sup>2</sup> = 9k<sup>2</sup> + 12k + 4 = 3(3k<sup>2</sup> + 4k + 1) + 1이므로 3으로 나눈 나머지는 1이 된다.
- 그러므로 어떤 자연수를 제곱하여도 그 결과를 3으로 나눈 나머지는 2가 아님이 성립된다.

---

<br>

#### (4) 귀류법

---

##### :one: 유리수와 무리수의 합은 무리수임을 증명하라.

- 귀류법은 모순 증명법이라고 한다.

- `p → q` 라는 본 명제가 있으면 `p → ~q` 라는 모순 명제를 선언하여 모순 명제가 참이면 본 명제는 거짓, 모순 명제가 거짓이면 본 명제는 참 임을 알 수 있다.
- 어떤 유리수(a)와 어떤 무리수(b)의 합이 유리수(c)가 된다고 가정하자.(모순 명제 선언)
- a + b = c, b = c - a가 되고, 이 때 c - a 값인 b는 유리수의 성질에 의해 유리수여야만 한다. 즉, 가정에 모순된다.
- 따라서 b가 무리수라는 가정에 모순되므로, 유리수와 무리수의 합은 무리수임을 증명할 수 있다.

<br>

##### :two: 루트2는 무리수임을 증명하라.

- 루트2 = b / a(<b>a, b는 서로소인 정수</b>) => `기약분수로 표현됨을 의미`, 즉 유리수라고 가정하자.
- 양 변에 a를 곱하고 제곱 => 2a<sup>2</sup> = b<sup>2</sup>이 되어 b<sup>2</sup>은 2의 배수가 된다.
- b<sup>2</sup>은 2의 배수이므로 b 또한 2의 배수이다.
- 이때, b가 2의 배수이므로 a<sup>2</sup> 및 a도 2의 배수가 된다.
- 이는 a, b는 서로소라는 조건에 모순되므로 루트2는 무리수이다.

<br>

##### :three:log<sub>2</sub>5는 무리수임을 증명하라.

- log<sub>2</sub>5 = b / a(<b>a, b는 서로소인 정수</b>) 즉, 유리수라고 가정하자.
- 2 <sup>b/a</sup> = 5이고, 양변을 a 제곱하게 되면, 2<sup>b</sup> = 5<sup>a</sup>이 된다.
- 하지만, 해당 수식을 만족하는 자연수 a, b는 존재하지 않는다.
- 따라서, 유리수라는 가정에 모순되므로 log<sub>2</sub>5는 무리수임을 증명할 수 있다.

---

<br>

#### (5) 수학적 귀납법

---

##### :one: 1 + 2 + 3 + ... + n = n(n+1)/2임을 증명하라.

- n = 1인 경우 1 = (1 × 2) / 2이므로 참이다. => `base case`인 경우
- n = k인 경우 주어진 명제가 성립한다고 가정하자.
  - 1 + 2 + 3 + ... + k = k(k+1)/2
- n = k + 1인 경우
  - `1부터 k까지의 합( k(k+1)/2 )` + (k + 1) = (k + 1)(k + 2)/2이면 참이 된다.
  - k(k+1)/2 + (k + 1) = (k<sup>2</sup> + k + 2k + 2) / 2 = (k<sup>2</sup> + 3k + 2) / 2 = (k + 1)(k + 2)/2
- 그러므로 1 + 2 + 3 + ... + n = n(n+1)/2임이 성립된다.

<br>

##### :two: 1<sup>2</sup> + 2<sup>2</sup> + 3<sup>2</sup> + ... + n<sup>2</sup> = n(n+1)(2n+1)/6임을 증명하라.

- 위 문제와 동일한 방법

- n = 1인 경우 참 / n = k인 경우 참이라고 가정한 후 n = k + 1일 때 식이 성립하는지 확인한다.

<br>

##### :three: 2 이상의 모든 자연수 n에 대해 n<sup>3</sup> - n은 6으로 나누어 떨어짐을 증명하라.

- n = 1일 때, 1 - 1 = 0, 6으로 나누어 떨어지므로 성립한다.
- n = k일 때 성립한다고 가정하자.
  - k<sup>3</sup> - k = 6m 식이 성립하게 된다. (`6으로 나누어 떨어짐`을 `6m`과 같이 나타낼 수 있다.)
- n = k + 1일 때, (k + 1)<sup>3</sup> - (k + 1) = k<sup>3</sup> + 3k<sup>2</sup> + 3k + 1 - k - 1 = k<sup>3</sup> +3k<sup>2</sup> +2k = k(k + 1)(k + 2)
  - (k + 1)<sup>3</sup> - (k + 1) = k(k + 1)(k + 2)는 연속된 세 수의 곱으로 이루어져 있고 이는 6으로 나누어 떨어진다.
- 그러므로 2 이상의 모든 자연수 n에 대해 n<sup>3</sup> - n은 6으로 나누어 떨어짐이 성립한다.

---

<br>

### 21.4 수의 표현

#### (1) 어떤 값 n을 표현하기 위해 필요한 비트 수

- 컴퓨터는 k개의 비트를 사용하면 0부터 2<sup>k</sup> - 1까지 표현이 가능하다.

- 2<sup>k</sup> - 1>= n 이 성립해야 함 => 즉, 2<sup>k</sup> >= n + 1
- 같은 의미로 k >= log(n + 1) => 약 logn 비트가 필요
- x = logn과 2<sup>x</sup> = n 은 같은 말
- 컴퓨터 분야에서 로그의 밑은 항상 2이며 주로 생략한다.

<br>

#### (2) `log n`의 의미(반드시 알아두자!!)

- 2의 몇 승이 n이 되느냐의 답
- n을 표현하는 데 몇 비트가 필요한가의 답
- 1로 시작해서 계속 두 배를 할 때 몇 번 하면 n이 되느냐의 답
- n을 2로 계속 나눌 때 몇 번 나누면 거의 1이 되느냐에 대한 답

---

:heavy_plus_sign: <b>추가내용</b>

- <b>2진수 표현에서 log n 비트로 표현할 수 있는 숫자 범위</b>
  - 0 ~ (n - 1)까지 총 n 가지 2진수를 표현할 수 있다.
- <b>[점근적 분석법] n이 충분히 큰 값일 때 크기 비교</b>
  - 2n < n<sup>2</sup>
  - 2<sup>(n/2)</sup> < 루트(3<sup>n</sup>)
  - 2<sup>nlogn</sup> > n!
  - log2<sup>2n</sup> < n×루트n
- <b>x = log<sub>a</sub>yz를 2를 밑으로 하는 로그들로 표현하기</b>
  - x = (log<sub>2</sub>x + log<sub>2</sub>y)/log<sub>2</sub>a
- <b>역함수 구하기</b>
  - f(x) = 3log(x + 3) + 1  =>  f(x) - 1 = 3log(x + 3)  =>  log(x + 3) = (f(x) - 1) / 3
  - x + 3 = 10<sup>(f(x) - 1)/3</sup>  =>  x = 10<sup>(f(x) - 1)/3</sup> - 3
  - x와 f(x) 자리 바꾼 후 f(x)를 f<sup>-1</sup>(x)로 바꾸면 끝!
  - f<sup>-1</sup>(x) = 10<sup>(x - 1)/3</sup> - 3

---

<br>

------

<br>

## 22. 10월08일(29일차)

### 22.1 집합과 조합론

#### (1) 집합

- 두 집합 A와 B에 대해 A가 B의 부분집합임을 증명한다는 것은 A의 임의의 원소가 B에 포함됨을 보이는 것과 같다.
- 두 집합 A와 B가 같다는 것을 증명하기 위해서는 A가 B의 부분집합이고 B가 A의 부분집합임을 증명하면 된다.

<br>

#### (2) 조합(순열 또는 조합 공식 쓰는 문제 출제!)

- 순열 : <sub>n</sub>P<sub>r</sub> = n! / (n - r)!
- 조합 : <sub>n</sub>C<sub>r</sub> = n! / (r! × (n - r)!)

<br>

#### (3) 증명 및 문제 풀이

---

:heavy_check_mark: <b>한정자(Quantifier)</b> : 논의 영역의 범위를 정의 <a href="https://m.blog.naver.com/PostView.nhn?blogId=maverickjin8&logNo=220252897028&proxyReferer=https%3A%2F%2Fwww.google.com%2F" target="_blank">(참고 페이지)</a>

- `전체한정자` : **∀** (for all)
  - `∀xP(x)` : 논의영역 U에 속하는 <b><u>모든 x</u></b>에 대해 P(x)는 참 / 논의영역의 모든 원소에 대해 만족할 경우에만 참이 된다. 
- `존재한정자` : **∃** (some)
  - `∃xP(x)` : 논의영역 U에 속하는 <b><u>어떤 x</u></b>에 대해 P(x)는 참 / 논의영역 원소 중 하나라도 만족하는 경우에는 참이 된다. 

---

##### :one: 이항 계수 공식 증명하기 (출처 : <a href="https://mathjk.tistory.com/163" target="_blank">(바로 이동)</a>)

<img src="https://user-images.githubusercontent.com/52685250/66358755-418fc300-e9af-11e9-944e-41a7d6c9e754.JPG" alt="이항계수 증명" width="500px">

:heavy_plus_sign: <b>[참고사항] 이항 계수와 파스칼의 삼각형 (출처 : <a href="https://m.blog.naver.com/PostView.nhn?blogId=lty2242&logNo=221091097459&proxyReferer=https%3A%2F%2Fwww.google.com%2F" target="_blank">(바로 이동)</a>)</b>

<img src="https://user-images.githubusercontent.com/52685250/66358814-756ae880-e9af-11e9-9edf-c22acc3dd0b6.JPG" alt="이항 계수와 파스칼의 삼각형" width="500px">

<br>

##### :two: 8 X 8 체스 판에 똑같은 말 두 개 놓을 때 가능한 방법의 수(반드시 알아두자!)

- 단 한 칸에 두 개가 들어가지 못한다는 전제 조건이 있다.
- 8×8 칸 중에서 순서 고려하지 않고 2개를 뽑는 경우의 수와 같으므로 <sub>8×8</sub>C<sub>2</sub> 를 계산하면 된다.
- <sub>64</sub>C<sub>2</sub> = <b>2016[가지]</b>

<br>

##### :three: n개의 원소를 가진 집합의 가능한 부분집합의 종류는 2<sup>n</sup>개임을 증명(조합론 이용)

- 임의의 원소가 부분 집합으로 포함될 경우는 2가지(포함된다, 포함되지 않는다)이므로, 전체 부분집합의 종류는 2<sup>n</sup>개이다.

<br>

##### :four: [중요!] 0 ~ 9까지 숫자를 최대 한 번만 사용한다고 할 때, 4개 이상 6개 이하의 숫자를 이용하여 만드는 비밀번호 가지수

- 숫자가 4개인 경우 => <sub>10</sub>P<sub>4</sub> (또는 10 × 9 × 8 × 7)
- 숫자가 5개인 경우 => <sub>10</sub>P<sub>5</sub> (또는 10 × 9 × 8 × 7 × 6)
- 숫자가 6개인 경우 => <sub>10</sub>P<sub>6 </sub>(또는 10 × 9 × 8 × 7 × 6 × 5)

- <sub>10</sub>P<sub>4</sub> + <sub>10</sub>P<sub>5</sub> + <sub>10</sub>P<sub>6</sub> = <b>186480[개]</b>

<br>

##### :five: 원소가 m개인 집합에서 원소가 n개인 집합으로 가는 단사함수의 개수

---

:heavy_check_mark: `함수의 정의역과 공변역의 대응 관계`에 따라 `단사 함수`, `전사 함수`, `전단사 함수`로 나뉜다.

- `단사 함수` : 일대일 함수
  - 정의역에 속하는 모든 원소가 서로 다른 공변역의 대응 원소를 갖음.
  - 공변역의 일부 원소는 정의역과 대응되지 않는 원소가 있을 수 있다.
  - 치역의 원소 개수 <= 공변역의 원소 개수
- `전사 함수` : 치역 = 공변역 이면서 공변역의 모든 원소가 대응되는 함수
  - 하나의 공변역 원소는 두 개 이상의 서로 다른 정의역 원소가 대응될 수 있음.
- `전단사 함수`
  - 하나의 정의역 원소가 하나의 공변역 원소와 서로 대응
  - 정의역의 원소 개수 = 공변역의 원소 개수 = 치역의 원소 개수

---

- m <= n인 경우
  - n개의 집합에서 m개를 선택하고, m개의 원소를 순열로 곱한 값이 총 개수이다.
  - 즉, <b><sub>n</sub>C<sub>m</sub> × m!</b>
- m > n인 경우
  - 단사 함수는 공역의 각 원소가 정의역의 원소 중 최대 한 원소만을 만족해야 하므로, 성립되지 않는다.

<br>

##### :six: 52개의 트럼프 카드 한 세트를 이용해서 만들 수 있는 5개 카드의 조합 가지수

- <sub>52</sub>C<sub>5</sub> [가지]

<br>

##### :seven: n개의 원소를 가진 배열에서 연속된 구간을 잡을 때 가능한 구간의 가지 수(단, 구간의 크기는 1 이상)

- n = 1인 경우 => ><b>n개</b>
- n >= 2인 경우
  - <b>n개 중 2개의 원소를 고르는 경우의 수</b>와 같다.
  - 2개를 고르면 그 사이에 있는건 연속된 구간이라고 하면 된다.

- <b>n + <sub>n</sub>C<sub>2</sub> [가지]</b>

<br>

### 22.2 기초 수식

#### (1) 알고리즘 복잡도

- 시간 복잡도(출처 : 위키백과)
  - 컴퓨터과학에서 알고리즘의 시간복잡도는 입력을 나타내는 문자열 길이의 함수로서 작동하는 알고리즘을 취해 시간을 정량화하는 것이다.
  - 주로 빅-오 표기법을 사용하여 나타내며, 계수와 낮은 차수의 항을 제외시키는 방법이다.

- 복잡도 표기법
  - 빅오 : `O(  )` => 최악의 경우(worst case에 대해 고려하는 것 / 점근선 상한선)
  - 오메가 : `Ω(  )` => 최선의 경우(점근선 하한선)
  - 쎄타 : `θ(  )` => 최악 = 최선인 경우(빅오랑 같다고 봐도 무방)

<br>

#### (2) O() notation으로 재귀식 풀기

##### :one: T(n) = T(n - 1) + logn

- T(n) = T(n - 2) + log(n - 1) + logn
- T(n) = T(n - 3) + log(n - 2) + log(n -1) + logn
- T(n) = T(n - (n - 1)) + log(n - (n - 1) + 1) + ... + logn
- T(n) = T(1) + log2 + log3 + ... + log(n-1) + logn
- log2, log3, log4,..., log(n - 1), logn 들을 logn으로 취급하면 이들은 모두 logn 보다 작거나 같으므로 다음과 같은 부등식이 성립된다.
- T(n) = T(1) + log2 + log3 + ... + log(n-1) + logn <= T(1) + logn + logn + ... + logn + logn
- T(n) <= T(1) + logn + logn + ... + logn + logn = T(1) + (n - 1)logn

- T(n) = T(1) + (n - 1)logn <= T(1) + nlogn
- <b>T(n) = O(nlogn)</b>

<br>

##### :two: T(n) = T(n / 2) + 1

- T(n / 2) = T(n / 4) + 1 + 1
- T(n / 4) = T(n / 8) + 1 + 1 + 1
- T(n / 8) = T(n / 16) + 1 + 1 + 1 + 1
- T(n) = T(1) + 1 + 1 + ... + 1
- T(n) = T(n / 2<sup>k</sup>) + 1 × k
- 이 때 2<sup>k</sup> = n에서 k = log<sub>2</sub>n이므로 1이 log<sub>2</sub>n번 만큼 반복되어 T(n) = T(1) + log<sub>2</sub>n으로 쓸 수 있다.
- T(n) = 1 + 1 + ... + 1(logn번 반복)
- <b>T(n) = O(logn)</b> (컴퓨터에서는 2인 밑을 생략함)

<br>

##### :three: T(n) = T(n / 2) + n

- <b>T(n) = O(n)</b>

<br>

##### :four: T(n) = T(n - 1) + (1/n)

- <b>T(n) = O(logn)</b>

<br>

### 22.3 재귀, 동적 프로그래밍

#### (1) 재귀함수 문제 해결방법

- n이 0일 때 문제를 풀 수 있음
- n - 1에서 문제를 풀 수 있으면 n에서도 문제를 풀 수 있다.
- 위 두 가지가 사실이면 모든 가능한 n에 대해 문제를 풀 수 있다.

<br>

#### (2) 재귀함수 vs 동적 프로그래밍

- 피보나치 함수를 두 가지 방법으로 풀었을 때 시간 복잡도 비교
  - 재귀 알고리즘으로 풀 때 시간 복잡도 : O(2<sup>n</sup>)
  - 메모이제이션을 이용한 DP로 풀 때 시간 복잡도 : O(n)
  - DP가 재귀함수보다 시간 복잡도가 많이 줄어드는 장점이 있다.