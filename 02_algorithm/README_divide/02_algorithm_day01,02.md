# :notebook_with_decorative_cover: 02_algorithm - Day01, 02

<br>

## 1. 7월29일(01일차)

### 1.1 알고리즘(algorithm)

- `알고리즘`의 정의
  - 컴퓨터가 어떤 일을 수행하기 위한 단계적 방법
  - 어떠한 문제를 해결하기 위한 절차
- 좋은 알고리즘의 조건
  - `정확성`↑(이게 제일 중요)
  - `작업량`↓, `메모리 사용량`↓, `단순성`, `최적성`

<br>

### 1.2 시간 복잡도(Time Complexity)

- 특징
  - **알고리즘의 작업량**을 표현할 때 사용
  - **실제 걸리는 시간**을 측정
  - **실행되는 명령문의 개수**를 계산
- 시간 복잡도 표현 방법
  - 빅오 : `O(  )` => 최악의 경우
  - 오메가 : `Ω(  )` => 최선의 경우
  - 씨타 : `θ(  )` => 최악 = 최선인 경우(빅오랑 같다고 봐도 무방)

> <n개 요소가 있는 List의 순차 검색에서 '최악'과 '최선'의 경우>
>
> 순차 검색 : key를 List의 첫 번째 요소부터 차례대로 검색하는 경우
>
> '최악' : 맨 마지막에 찾거나 없거나 => 1
>
> '최선' : 맨 처음에 발견 => n

- **빅-오(O) 표기법(Big-Oh Notation)**

  - n이 커지면 얼마나 복잡해지는지 알 수 있음

  - 시간 복잡도 함수 중에서 **<u>가장 큰 영향력을 주는 n에 대한 항만</u>**을 표시

  - ```python
    def func(n):
        # 실행문 --- 1번
        for i in range(n):
            # 실행문 --- n번
            for j in range(i, n):
                # 실행문 --- x번 (x를 대략 n*(n+1)/2 라고 하자)
              
    # => (n*(n+1)/2) + n + 1 = 2n^2 + 10n + 4
    # 가장 높은 차수의 항이 무엇인지 중요! => 이 알고리즘의 시간 복잡도 판단 가능!
    ```

  - **최고차항만 선택** 후 **계수(Coeffcient)는 생략**하여 표시

  - `O(2n^2+10n+4)` = `O(2n^2)` = `O(n^2)`

  - `O(4)` = `O(1)`

  - 빅-오 표기법에서 `logn`은 log<sub>2</sub> n이다.

- **순차 검색**에서 '최악'과 '최선'의 경우

  - 순차 검색 : key를 List의 첫 번째 요소부터 차례대로 검색하는 경우
  - '최악' : 맨 마지막에 찾거나 없거나 => 1
  - '최선' : 맨 처음에 발견 => n

- **이진 탐색**

  ![02_day01_01](https://user-images.githubusercontent.com/52685250/62020085-7091f780-b1fc-11e9-88c7-6c41131b6da3.JPG)

- P(Polynomial) 문제 집합 & NP 문제 집합

  - P 문제 집합 : 시간복잡도가 O(logn), O(n), O(nlogn), O(n<sup>2</sup>), O(n<sup>3</sup>) 
  - NP 문제 집합 : 위 보다 더 큰 시간복잡도를 가진 알고리즘으로 해결되는 문제 집합 ( O(2<sup>n</sup>), O(n!) )

<br>

### 1.3  정렬(Sort)

> `정렬(Sort)` : 2개 이상의 자료를 특정 기준에 의해 작은 값부터 큰 값(오름차순 : ascending), 혹은 그 반대의 순서대로(내림차순 : descending) 재배열하는 것

#### (1) 버블 정렬(Bubble Sort) (강의교안 : p.36)

- **<u>인접한 두 개의 원소</u>**를 비교하며 자리를 계속 교환하는 방식

- 정렬 과정(오름차순일 때)

  - 첫 번째 원소부터 인접한 원소끼리 계속 자리를 교환하면서 맨 마지막 자리까지 이동

  - 한 단계가 끝나면 가장 큰 원소가 마지막 자리로 정렬

  - ```
    list = [55, 7, 78, 12, 42]과 같이 원소가 5개인 리스트의 경우
    
    1st 패스 : (0, 1) - (1, 2) - (2, 3) - (3, 4) => list[4] 결정
    2nd 패스 : (0, 1) - (1, 2) - (2, 3) => list[3] 결정
    3rd 패스 : (0, 1) - (1, 2) => list[2] 결정
    4th 패스 : (0, 1) => list[1] 결정 후 이어서 바로 list[0] 결정
    ```

  - list의 요소가 n개인 경우 n-1번 버블 정렬을 거치면 된다.

- 시간 복잡도 : O(n<sup>2</sup>)

```python
arr = [55, 7, 78, 12, 42]
n = len(arr) # list의 길이

for i in range(n-1, 0, -1): # 한 패스당 마지막 위치 지정(-1step)
    for j in range(i):
        if arr[j] > arr[j+1]:
            arr[j], arr[j+1] = arr[j+1], arr[j] # swap

print(arr)
```

<br>

#### (2) 선택 정렬(Selection Sort)(오름차순) 맛보기 (강의교안 : p.90)

- 정렬과정

```
list = [55, 7, 78, 12, 42]과 같이 원소가 5개인 리스트의 경우

1st 패스 : (0, 1) - (0, 2) - (0, 3) - (0, 4) => list[0] 결정
2nd 패스 : (1, 2) - (1, 3) - (1, 4) => list[1] 결정
3rd 패스 : (2, 3) - (2, 4) => list[2] 결정
4th 패스 : (3, 4) => list[3] 결정 후 이어서 바로 list[4] 결정
```

```python
arr = [55, 7, 78, 12, 42]

for j in range(len(arr)-1):
    min = j
    
    for i in range(j+1, len(arr)):
        if arr[i] < arr[min]:
            min = i

    arr[j], arr[min] = arr[min], arr[j]
    
print(arr)
```

<br>

#### (3) 카운팅 정렬(Counting Sort) (강의교안 : p.42)

- 항목들의 순서를 결정하기 위해 집합에 각 항목이 **<u>몇 개씩 있는지 세는 작업</u>**을 하여, **선형 시간(즉, 일차 함수, linear)에 정렬**하는 효율적인 알고리즘

- **<u>실제의 값 자체를 인덱스(index)로 활용</u>**한다. 그래서 값의 범위를 알아야 한다.(즉, 최댓값을 알아야 한다.)

- 제한 사항

  - 카운트들을 위한 충분한 공간을 할당하려면 **집합 내의 가장 큰 정수를 알아야** 한다.
  - 정수나 정수로 표현할 수 있는 자료에 대해서만 적용 가능(음수 불가능) : 정렬할 값들이 **양의 정수** 또는 변환할 값들이 양의 정수일 때 가능. 문자열인 경우 양의 정수로 매핑할 수 있는 경우 가능.

- 시간 복잡도 : O(n+k) (단, n은 리스트의 길이, k는 정수의 최댓값)

- 정렬과정

  - ```python
    # Step 1
    
    data = [0, 4, 1, 3, 1, 2, 4, 1]
    counts = [0] * 5 # 최댓값 = 4 이므로 0이 5개가 있는 리스트를 먼저 만든다.
    
    for val in data:
        counts[val] += 1
    
    print(counts) # => [1, 3, 1, 1, 2]
    ```

  - ```python
    # Step 2-(1)(꼼수 카운팅 정렬 방법)
    
    data = [0, 4, 1, 3, 1, 2, 4, 1]
    counts = [0] * 5 # 최댓값 = 4 이므로 0이 5개가 있는 리스트를 먼저 만든다.
    
    for val in data:
        counts[val] += 1
    
    sorted = []
    for i in range(len(counts)):
        for j in range(counts[i]):
            sorted.append(i)
    print(sorted) # => [0, 1, 1, 1, 2, 3, 4, 4]
    ```

  - ```python
    # Step 2-(2)(누적 빈도수 계산)
    
    # 강의 교안 정렬 과정을 보고 코드를 작성해보자.
    
    data = [0, 4, 1, 3, 1, 2, 4, 1]
    counts = [0] * 5
    temp = [0] * len(data)
    
    for val in data:
        counts[val] += 1
    
    for i in range(1, len(counts)):
        counts[i] = counts[i-1] + counts[i] # 누적 빈도수 계산하여 counts의 원소를 조정
    
    for j in range(len(data)-1, -1, -1):
        counts[data[j]] -= 1
        temp[counts[data[j]]] = data[j]
    
    print(temp)
    ```

<br>

#### (4) 완전 탐색(Exaustive Search)(Brute-force 혹은 generate-and-test 기법)

> `최적화 문제` : 최대 혹은 최소가 되는 경우를 찾는 문제

- 문제의 해법으로 생각할 수 있는 **<u>모든 경우의 수를 나열해보고 확인</u>**하는 기법
- 모든 경우의 수를 테스트한 후, 최종 해법을 도출
- 일반적으로 경우의 수가 상대적으로 작을 때 유용
- 모든 경우의 수를 생성하고 테스트하기 때문에 수행 속도는 느리지만, 해답을 찾아내지 못할 확률이 작음
- `순열`, `조합` 같은 조합론 개념을 알아두면 용이

<br>

#### (5) 순열(Permutation)

```python 
# ABC 문자 세 개로 배열할 수 있는 모든 경우 나열(중복순열)

data = 'ABC'

n = len(data)
for i in range(n):
    for j in range(n):
        for k in range(n):
            print(data[i], data[j], data[k])


```

```python
# 위 중복순열 코드를 순열 코드로 변경 ==> 나중엔 이거를 재귀호출로 작성할 것임.(백 트래킹???)

data = 'ABC'

n = len(data)
for i in range(n):
    for j in range(n):
        if i == j: continue
        for k in range(n):
            if i == k or j == k: continue
            print(data[i], data[j], data[k])
"""
A B C
A C B
B A C
B C A
C A B
C B A
"""


```

<br>

------

<br>

## 2. 7월30일(02일차)

### 2.1 최적화 문제

#### (1) 최적화 문제의 기본 해결 방법 → `완전 검색`

- 최대 혹은 최소가 되는 경우를 찾는 문제
- 모든 가능한 경우를 조사한다.
- 모든 후보해를 조사한다.
- 모든 가능한 경우들이 조합과 관련이 깊다.
  - 순열(n!), 부분집합(2<sup>n</sup>), 조합

<br>

#### (2)완전 검색을 좀 더 효율적으로 하는 방법

- 백 트래킹(가지치기)
- 동적 계획법(메모이제이션)
- 즉, `백 트래킹`과 `동적 계획법` 둘 다 모두 완전 검색이다.
- 완전 검색과는 별개로 `분할 정복`, `탐욕` 방법이 있다.

<br>

### 2.2 탐욕(Greedy) 알고리즘

- **최적해**를 구하는 데 사용되는 근시안적인 방법
- 여러 경우 중 하나를 결정해야 할 때마다 **<u>그 순간에 최적이라고 생각되는 것을 선택</u>**해 나가는 방식으로 진행하여 최종적인 해답에 도달
