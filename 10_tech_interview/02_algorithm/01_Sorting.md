# 01. Sorting Algorithm

<br>

## (1) 버블 정렬

- 인접한 두 개의 데이터를 비교해가면서 정렬하는 방식
- 첫 번째 원소부터 인접한 원소끼리 계속 자리를 교환하면서 맨 마지막 자리까지 이동
- 한 단계가 끝나면 가장 큰 원소가 마지막 자리로 정렬된다.
- 배열의 원소가 n개인 경우 n - 1번 버블 정렬 과정을 거치면 된다.

```
list = [55, 7, 78, 12, 42]과 같이 원소가 5개인 리스트의 경우

1st 패스 : (0, 1) - (1, 2) - (2, 3) - (3, 4) => list[4] 결정
2nd 패스 : (0, 1) - (1, 2) - (2, 3) => list[3] 결정
3rd 패스 : (0, 1) - (1, 2) => list[2] 결정
4th 패스 : (0, 1) => list[1] 결정 후 이어서 바로 list[0] 결정
```

<br>

## (2) 선택 정렬

- n개의 원소를 가진 배열을 정렬할 때, 계속해서 바꾸는 것이 아니라 비교하고 있는 값의 index를 저장해두면서  최종적으로 비교된 값을 해당 index 위치에 저장한다.
- 이러한 과정을 n - 1번 선택 정렬 과정을 거치면 된다.

```
list = [55, 7, 78, 12, 42]과 같이 원소가 5개인 리스트의 경우

1st 패스 : (0, 1) - (0, 2) - (0, 3) - (0, 4) => list[0] 결정
2nd 패스 : (1, 2) - (1, 3) - (1, 4) => list[1] 결정
3rd 패스 : (2, 3) - (2, 4) => list[2] 결정
4th 패스 : (3, 4) => list[3] 결정 후 이어서 바로 list[4] 결정
```

<br>

## (3) 삽입 정렬

- 정렬된 부분 배열 형태를 유지하며 진행하는 방식으로 새로운 숫자가 삽입되면 정렬된 부분 배열 안에서 자기의 자리를 찾아가며 정렬하는 방식
- n 개의 원소를 가진 배열을 정렬할 때, i 번째를 정렬할 순서라고 가정하면 0부터 i - 1번째 원소들은 정렬되어있다는 가정하에, i 번째 원소와 i - 1번째 원소부터 0번째 원소까지 비교하면서 i 번째 원소가 비교하는 원소보다 클 경우 서로의 위치를 바꾸고, 작을 경우 위치를 바꾸지 않고 다음 순서의 원소와 비교하면서 정렬한다.
- 이 과정을 정렬하려는 마지막 원소까지 반복한다.

<br>

## (4) 병합 정렬

- 합병 정렬이라고도 부르며, 분할 정복 방법을 통해 구현
  - 분할 정복 : 큰 문제를 작은 문제 단위로 쪼개면서 해결해나가는 방식
- 영역을 쪼갤 수 있을 만큼 쪼갠 후 그 안에서 정렬하고 하나의 영역으로 병합하는 과정을 1개의 영역으로 병합될 때까지 반복하면서 정렬하는 방식

<br>

## (5) 퀵 정렬

- 병합 정렬과 마찬가지로 분할 정복 기법을 통해 구현한다.

- 정렬 과정
  - 열 중에서 하나의 원소(피벗)을 고른다.
  - 피벗 앞에는 피벗보다 작은 모든 원소들이 오고, 피벗 뒤에는 피벗보다 큰 원소들이 오도록 피벗을 기준으로 배열을 둘로 나눈다.
  - 각 부분 정렬이 끝난 후,  피벗은 더 이상 움직이지 않는다.
  - 분할된 두 개의 작은 배열에 대해 재귀적으로 이 과정을 반복하며 정렬한다.
- 병합 정렬과 다른 점은 병합 정렬은 각 부분집합에서 정렬을 마친 후 '병합' 이라는 후처리 작업이 필요하나 퀵 정렬은 필요하지 않다.
- 주의해야 할 점은 재귀적으로 분할된 작은 배열에서 피벗으로 설정되었던 값들은 다음 재귀과정에 포함시키지 않아야 한다.
  - 이미 이 값들은 자신의 위치를 찾았기 때문이다.

<br>

## (6) 힙 정렬

- 완전 이진 트리를 기본으로 하는 힙 자료구조를 활용하는 정렬 방식

<br>

## (7) 카운팅 정렬

- 항목들의 순서를 결정하기 위해 집합에 각 항목이 몇 개씩 있는지 세는 작업을 하여, 선형 시간(즉, 일차 함수, linear)에 정렬하는 효율적인 알고리즘
- 실제의 값 자체를 인덱스(index)로 활용한다. 그래서 값의 범위를 알아야 한다.(즉, 최댓값을 알아야 한다.)
- 정렬 과정
  - 카운트를 위한 충분한 공간을 할당해주기 위해 집합 내의 가장 큰 정수를 알아낸 후 그 정수 길이 만큼 모든 값을 0으로 초기화한 counting 배열을 만들어준다.(counting 배열 : 각 숫자가 몇 번 등장했는지 셈)
  - counting 배열을 누적합으로 만들어준다.
  - 뒤에서부터 counting 배열을 돌면서, 해당하는 값의 인덱스에 값을 넣어준다.
- 장점: <b>O(n)</b>의 시간 복잡도
- 단점: 배열 사이즈 N 만큼 돌 때, 증가시켜주는 counting 배열의 크기가 큼(메모리 낭비가 심함)

<br>

## :mag: 정렬 알고리즘의 복잡도 비교

| 정렬 알고리즘 | 시간 복잡도                               | 공간 복잡도 |
| ------------- | ----------------------------------------- | ----------- |
| 버블 정렬     | O(n<sup>2</sup>) - 평균, 최악             | O(n)        |
| 선택 정렬     | O(n<sup>2</sup>) - 평균, 최악             | O(n)        |
| 삽입 정렬     | O(n<sup>2</sup>) - 평균, 최악             | O(n)        |
| 병합 정렬     | O(nlogn) - 평균, 최악                     | -           |
| 퀵 정렬       | O(nlogn) - 평균 / O(n<sup>2</sup>) - 최악 | O(n)        |
| 힙 정렬       | O(nlogn) - 평균, 최악                     | -           |
| 카운팅 정렬   | O(n + k) - 평균, 최악                     | O(k)        |

