# 01. 브라우저 동작 원리

<br>

## (1) 브라우저 주요 기능

- 사용자가 선택한 자원을 서버에 요청하고 브라우저에 표시하는 것
- 자원은 보통 HTML 문서지만 PDF나 이미지 또는 다른 형태일 수 있다.
- 자원의 주소는 URI(Uniform Resource Identifier)에 의해 정해진다.

---

:heavy_check_mark: <b>[참고] URL vs URI</b>

![urlurn](https://user-images.githubusercontent.com/52685250/93211581-67ffd600-f79c-11ea-982a-82c163230546.png)

- URL(Uniform Resource Locator)
  - 자원
  - 예전에는 URL이 가리키는게 파일 소스
  - resource를 접근할 수 있는 위치를 나타냄
  - 네트워크 상에서 자원이 어디 있는지를 알려주기 위한 규약
  - 즉, 컴퓨터 네트워크와 검색 메커니즘에서의 위치를 지정하는 웹 리소스에 대한 참조
- URI(Uniform Resource Identifier)
  - 통합 자원 식별자
  - 인터넷에 있는 자원을 나타내는 유일한 주소
  - URI의 존재는 인터넷에서 요구되는 기본조건으로서 인터넷 프로토콜에 항상 붙어 다닌다.
  - URI의 하위 개념에 URL, URN이 포함되어 있다.

- 인터넷 주소로 예를 들어 설명

  ```
  https://wally-wally.kr/til/algorithm?problemNo=40392?lang=python
  ```

  - 위와 같은 주소가 있다고 가정할 때 `https://wally-wally.kr/til/algorithm` 여기까지는 URI이면서 URL이고 `https://wally-wally.kr/til/algorithm?problemNo=40392?lang=python` 주소 전체는 URI라고 할 수 있다.
  - URL은 자원의 위치를 나타내는 것이고 URI는 자원의 식별자인데 query string형태로 붙은 `?problemNo=40392?lang=python`은 위치를 나타내는 것이 아니라 problemNo 값이 40392이고 lang 값이 python인 것을 나타내주는 식별하는 부분이기 때문이다.

- 참고로 URN(Uniform Resource Name)은 resource의 name을 나타낸다.

  - ISBN 시스템 처럼 접근할 수 있는 위치가 아닌 이름으로 표시된다.

---

- 브라우저는 웹 표준화 기구인 `W3C` 에서 정한 HTML, CSS 명세에 따라 HTML 파일을 해석해서 표시한다.
  - 예전 브라우저들은 일부만 명세에 따라 구현하고 독자적 방법으로 확장해서 심각한 호환성 문제가 발생했다. 요즘은 대부분 표준 명세를 따르고 있다.

<br>

## (2) 브라우저 기본 구조

![helloworld-59361-1](https://user-images.githubusercontent.com/52685250/93211977-f07e7680-f79c-11ea-87f5-aded66992bbe.png)

- 사용자 인터페이스
  - 주소 표시줄, 이전/다음 버튼, 북마크 메뉴 등. 요청한 페이지를 보여주는 창을 제외한 나머지 모든 부분
- 브라우저 엔진
  - 사용자 인터페이스와 렌더링 엔진 사이의 동작을 제어

- 렌더링 엔진
  - 요청한 콘텐츠를 표시
  - HTML을 요청하면 HTML과 CSS를 parsing하여 화면에 표시
- 통신
  - HTTP 요청과 같은 네트워크 호출에 사용
  - 플랫폼의 독립적인 인터페이스로 구성되어 있음
- UI 백엔드
  - 플랫폼에서 명시하지 않은 일반적인 인터페이스.
  - 콤보 박스 창 같은 기본적 장치를 그림
- 자바스크립트 해석기
  - 자바스크립트 코드를 해석하고 실행
- 자료 저장소
  - 쿠키 등 모든 종류의 자원을 하드 디스크에 저장하는 계층

<br>

## (3) 브라우저 동작 원리

![image_3480670191498924844279](https://user-images.githubusercontent.com/52685250/93212652-d4c7a000-f79d-11ea-8403-30d05143f0b1.png)

[1] 서버에서 응답 받은 HTML 데이터 파싱

[2] HTML을 파싱한 결과로 마크업 처리 후 <b>DOM Tree</b>를 만듬 => <b>무엇을</b> 그릴지 결정

[3] 파싱하는 중 CSS 파일 링크를 만나면 CSS 파일을 요청해서 받음

[4] CSS 파일을 읽어서 <b>CSSOM Tree</b>를 만듬 => <b>어떻게</b> 그릴지 결정

[5] 만든 DOM Tree와 CSSOM Tree를 결합하여 <b><u>렌더링 트리</u></b>를 만듬 => <b>화면에 그려질 것만</b> 결정

[6] 렌더링 트리에 있는 각각의 노드들이 화면의 어디에 어떻게 위치할지 계산하는 <b>Layout</b> 과정을 거침 => <b>Box-model</b> 생성

[7] UI 백엔드에서 렌더링 트리의 각 노드를 가로지으며 실제로 그리는 <b>paint</b> 과정을 거침

<br>

## (4) 렌더링

- 렌더링 엔진은 요청 받은 내용을 브라우저 화면에 표시하는 일

- 렌더링 엔진 종류

  - 크롬, 사파리 : webkit 엔진
  - 파이어폭스 : gecko 엔진

- 동작 과정

  ![helloworld-59361-2](https://user-images.githubusercontent.com/52685250/93213800-494f0e80-f79f-11ea-8c95-0a1b176920fd.png)

- (3) 에서 살펴본 과정이 점진적으로 진행되며, 렌더링 엔진을 좀더 빠르게 사용자에게 제공하기 위해 모든 html 을 파싱할 때까지 기다리지 않고 배치와 그리기 과정을 시작한다.

- 전송을 받고 기다리는 동시에 받은 내용을 먼저 화면에 보여준다
  (우리가 웹페이지에 접속할 때 한꺼번에 뜨지 않고 점점 화면에 나오는 것이 이 때문!!!)

<br>

## (5) 파싱, DOM 트리 구축

- 파싱(parsing)
  - **문서 파싱은 브라우저가 코드를 이해하고 사용할 수 있는 구조로 변환하는 것**
  - 파싱 결과는 보통 문서 구조를 나타내는 노드 트리인데 파싱 트리 또는 문법 트리라고 부른다.
- 파서-어휘 분석기 조합
  - 어휘 분석과 구문 분석 과정을 거쳐 파싱 트리를 구축한다.
  - 어휘 분석 : 자료를 토큰으로 분해
    - 여기서 토큰은 유효하게 구성된 단위의 집합체(인간의 언어로 말하자면 사전에 등장하는 모든 단어)
  - 어휘 분석기를 통해 언어의 구문 규칙에 따라 문서 구조를 분석 => 파싱 트리 생성하는 파서
    - 어휘 분석기 : 공백과 줄 바꿈 같은 의미 없는 문자를 제거함
  - 이 과정에서 구문 규칙과 일치하는 지 비교하고 일치하는 노드만 파싱 트리에 추가하는 작업을 반복
  - 만약 끝까지 규칙이 맞지 않는 부분이 있으면 예외로 처리하는데 이것은 문서가 유효하지 않고 구문 오류를 포함하고 있다는 의미이다.
- 여기서 파싱 트리가 나왔다고 끝난 것이 아니다.
  - 컴파일의 과정일 뿐 다시 기계코드 문서로 변환하는 과정까지 완료되어야 최종 결과물이 나오게 된다.
  - 보통 이런 파서를 생성하는 것은 문법에 대한 규칙 부여 등 복잡하고 최적화하기 힘드므로, 자동으로 생성해주는 `파서 생성기`를 많이 활용한다.
- 이와 같은 파싱 과정을 거치면서 서버로부터 받은 문서를 브라우저가 이해하고 쉽게 사용할 수 있는 DOM Tree 구조로 변환시켜주는 것이다.

<br>

## (6) Reflow, Repaint

- Reflow, Repaint 개념
  - 생성된 DOM 노드의 레이아웃 수치가 변할 때 영향 받는 모든 노드들의 수치를 다시 계산하여 렌더 트리를 재생성하는데 이 과정을 reflow라고 한다.
  - 그리고 새로 재생성된 렌더 트리를 다시 화면에 그리는 과정을 repaint 과정이라고 한다.
- 그러면 모든 노드가 변경될 때마다 reflow가 일어나는가
  - 노드 스타일의 모든 변경이 레이아웃 수치에 영향을 받는 것은 아니다.
  - background-color, visibility, outline 등의 스타일 변경 시에는 레이아웃 수치가 변하지 않기 때문에 repaint 과정만 일어난다.
- 참고로 사용하지 않는 노드는 `visibility: hidden;` 보다 `display: none;` 사용하는 것이 좋다.

<br>

## :mag: 최종 정리

① 주소창에 url을 입력하고 Enter를 누르면, <b>서버에 요청 전송</b>

② 해당 페이지에 존재하는 <b>여러 자원들(text, image, video 등등)이 보내짐</b>

③ 렌더링 엔진을 통해서 브라우저는 해당 자원이 담긴 html과 스타일이 담긴 css를 <b>명세에 따라 해석</b>

④ 렌더링 엔진은 html 파싱 과정을 진행하고 어휘 분석과 구문 분석을 하면서 <b>DOM Tree</b>를 만듬

⑤ 그 다음으로 css 파싱 과정을 거치면서 <b>CSSOM Tree</b>를 만듬

⑥ 이 두 가지 Tree를 하나로 합쳐 <b>Render Tree</b>를 만듬

⑦ 화면에 어떻게 <b>배치</b>할지 결정하고 UI 백엔드가 노드를 돌면서 형상을 <b>그림</b>

(만약 중간에 script 태그를 만나면 자바스크립트 코드를 실행하기 위해 DOM Tree 생성 과정(파싱 과정)을 잠시 중단하고 자바스크립트 엔진으로 제어 권한을 넘겨 자바스크립트 코드를 읽는 과정을 수행)

<br>

---

:page_facing_up: <b>Reference</b>

- https://d2.naver.com/helloworld/59361
- https://velog.io/@pa324/%EA%B0%9C%EB%B0%9C%EC%83%81%EC%8B%9D-URI-URL-%EC%B0%A8%EC%9D%B4-%EC%A0%95%EB%A6%AC
- https://gyoogle.dev/blog/web-knowledge/%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80%20%EB%8F%99%EC%9E%91%20%EB%B0%A9%EB%B2%95.html
- https://m.post.naver.com/viewer/postView.nhn?volumeNo=8431285&memberNo=34176766

---

