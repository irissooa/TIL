# 3. Tree = >비선형 자료구조

<br>

### (1) Tree

- 비선형 자료구조로 계층적 관계를 표현하는 자료구조
- 싸이클이 없는 무향 연결 그래프

<img src="https://user-images.githubusercontent.com/52685250/66529554-d543c980-eb3e-11e9-9b40-20eb93b7c497.JPG" alt="트리" width="600px">

<br>

### (2) 이진 트리

- 모든 노드들이 최대 2개의 서브 트리를 갖는 형태의 트리
- 루트 노드의 레벨을 0으로 시작해서 트리에 있는 노드의 높이 중 가장 큰 값(최대 레벨)을 그 트리의 높이라고 한다.
  - 이 높이를 이용해서 시간 복잡도를 계산할 수 있다.
- 포화 이진 트리(Perfect Binary Tree)
  - 모든 레벨에 노드가 포화상태로 꽉 채워져 있는 트리
  - 높이가 h일 때 최대의 노드 개수인 2<sup>h+1</sup>-1 의 노드를 가진 이진 트리
- 완전 이진 트리(Complete Binary Tree)
  - 위에서 아래로, 왼쪽에서 오른쪽으로 순서대로 차곡차곡 채워진 이진 트리
  - 높이가 h이고 노드 수가 n개일 때, `포화 이진 트리의 노드 번호 1번부터 n번까지 빈 자리가 없는` 이진 트리
- 편향 이진 트리(Skewed Binary Tree)
  - 높이 h에 대한 최소 개수의 노드를 가지면서 한쪽 방향의 자식 노드만을 가진 이진 트리

<br>

### (3) BST (Binary Search Tree)

- 탐색을 효율적으로 하기 위한 트리 구조

- 데이터 저장 규칙
  - 중복되는 노드가 없어야 한다.(BST는 검색 목적 자료구조인데 굳이 중복이 많은 경우 트리를 사용하여 검색 속도를 느리게 할 필요가 없다. 오히려 노드에 count 값을 가지게 하여 처리하는 것이 훨씬 효율적)
  - 왼쪽 자식 노드  < 부모의 키 < 오른쪽 자식 노드
  - 왼쪽과 오른쪽 서브 트리도 이진 탐색 트리이다.
  
- 이진 탐색 트리를 중위 순회하면 오름차순으로 정렬된 값들을 얻을 수 있다.

- 탐색 연산 : <b>O(logn)</b>의 평균적인 시간 복잡도(정확하게는 <b>O(h)</b>)
  
  - 편향 이진 트리와 같이 최악의 경우에는 <b>O(n)</b>의 시간 복잡도를 가짐 (순차탐색과 시간 복잡도가 동일)
  
- 배열보다 많은 메모리를 사용하며 데이터를 저장했지만 편향 이진 트리의 경우 탐색에 필요한 시간 복잡도가 같게 되는 비효율적인 상황이 발생한다.
  
  - 이를 해결하기 위해 `Rebalancing` 기법(균형을 잡기 위한 트리 구조의 재조정)이 등장하였다. ex) AVL Tree, Red Black Tree
  
- 삭제의 3가지 Case

  - 자식이 없는 leaf 노드일 때 → 그냥 삭제

  - 자식이 1개인 노드일 때 → 지워진 노드에 자식을 올리기

  - 자식이 2개인 노드일 때 → 오른쪽 자식 노드에서 가장 작은 값 or 왼쪽 자식 노드에서 가장 큰 값 올리기

<br>

### (4) Heap

- Tree 형태를 띄고 있는 자료 구조로 배열에 기반한 완전 이진 트리이다.
- 이진 트리와 달리 Heap Tree는 중복된 값을 허용한다.
- 루트 노드부터 1번으로 인덱스 번호 시작
  - 노드 고유번호 값과 배열의 인덱스를 일치시켜 혼동을 줄이기 위함이다.
- 특정 위치의 노드 번호는 새로운 노드가 추가되어도 변하지 않음
- 완전 이진 트리에 있는 노드 중에서 키 값이 가장 큰 노드가 키 값이 가장 작은 노드를 찾을 때 용이함
  - 그래서 최대 힙에서 최대값을 찾거나 최소 힙에서 최소 값을 찾을 때 소요되는 연산의 시간 복잡도는 <b>O(1)</b>이다.
- 최대 힙(Max Heap)
  - 부모 노드가 자식 노드들보다 값이 크거나 같다.
  - 키 값이 가장 큰 노드를 찾기 위한 완전 이진 트리
- 최소 힙(Min Heap)
  - 최대 힙과 반대로 부모 노드보다 자식 노드들의 값이 크거나 같다.
  - 키 값이 가장 작은 노드를 찾기 위한 완전 이진 트리
- Python에서는 `heapq` 라는 라이브러리가 있다.

<br>

### (5) B-Tree, B+Tree

- B-Tree
  - 이진 트리를 확장해서, 더 많은 수의 자식을 가질 수 있게 일반화 시킨 것이 B-Tree
  - 각 노드에 데이터가 저장됨
- B+Tree
  - B-Tree의 변형 구조로, index 부분과 leaf 노드로 구성된 순차 데이터 부분으로 이루어진다. 인덱스 부분의 key 값은 leaf에 있는 key 값을 직접 찾아가는데 사용함.
  - leaf 노드는 서로 연결되어 있어서 임의접근이나 순차접근 모두 성능이 우수함
  - B+tree는 각 노드에서 key만 들어감. 따라서 data는 모두 leaf 노드에만 존재
  - B+tree는 add와 delete가 모두 leaf 노드에서만 이루어짐

<br>

---

:page_facing_up: <b>Reference</b>

- https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/DataStructure

---

