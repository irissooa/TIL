# 1. Array, Linked List

<br>

## (1) Array

- 가장 기본적인 자료구조로 논리적 저장 순서와 물리적 저장 순서가 일치
  - 그렇기 때문에 인덱스로 해당 원소에 접근 가능 => 찾고자 하는 원소의 인덱스 값을 알고 있으면 <b>O(1)</b>의 시간 복잡도로 해당 원소에 접근 가능
- 하지만 삭제 또는 삽입 과정에서는 원소의 이동 작업이 추가로 필요해서 이보다 조금 복잡한 시작 복잡도를 가짐
  - 해당 원소에 우선 접근에서 삭제 또는 삽입 과정 수행 => <b>O(1)</b>
  - 만약 삭제한 경우 빈 공간이 생겨 배열의 연속적인 특징이 깨지므로 이를 해결하기 위해 삭제한 원소보다 큰 인덱스를 갖는 원소들을 shift 해줘야하는 비용이 발생 => <b>O(n)</b>
  - 삽입하는 경우도 모든 원소들의 인덱스를 1 씩 shift 해줘야함 => <b>O(n)</b>
  - 그렇기 때문에 Array의 자료구조에서 삭제나 삽입 과정에서 시간 복잡도의 최악의 경우는 <b>O(n)</b>이 된다.

<br>

## (2) Linked List

- Array의 이러한 문제점을 해결하기 위한 자료구조로 Linked List가 있다.
- 각각의 원소들은 자기 자신 다음에 어떤 원소인지만 기억하고 있다.
  - 따라서 이 부분만 다른 값으로 바꿔주면 되기 때문에 삭제 또는 삽입 과정에서의 시간 복잡도는 <b>O(1)</b>이 된다. 그래서 링크를 통해 원소에 접근하기 때문에 일반적인 Array처럼 물리적인 순서를 맞추기 위한 작업이 필요하지 않다.

<img src="https://user-images.githubusercontent.com/52685250/64085538-5b196b80-cd6e-11e9-9d20-6890c5a962c1.JPG" width=700px height=120px>

- 하지만 Linked List에서도 치명적인 문제가 있다.
- 원하는 위치에 삽입하고 싶을 때 원하는 위치는 찾는 과정에서 첫 번째 원소부터 다 확인해야 한다.
  - 왜냐하면 Array와는 달리 논리적 저장 순서와 물리적 저장 순서가 일치하지 않기 때문이다.
  - 그렇기 때문에 어떠한 원소를 삭제 또는 삽입하고자 했을 때, 그 원소를 찾기 위해서 <b>O(n)</b>의 시간이 추가적으로 발생한다.

<br>

### :mag: 정리

| 동작   | Array             | Linked List       |
| ------ | ----------------- | ----------------- |
| Search | O(1)              | O(n) (Worse Case) |
| Add    | O(n) (Worse Case) | O(1)              |
| Delete | O(n) (Worse Case) | O(1)              |

상황에 따라서 적절한 자료구조를 사용하자.(Tree 같은 경우 Linked List의 기본이 된다.)

<br>

---

:page_facing_up: <b>Reference</b>

- https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/DataStructure

---

