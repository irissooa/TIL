# 01. 프로세스와 스레드

<br>

## (1) 프로세스

![프로세스](https://github.com/jr31112/Prepare-Interview/raw/master/os/process%26thread/process.png)

- **컴퓨터에서 연속적으로 실행되고 있는 컴퓨터 프로그램**
- 메모리에 적재되어 실행되고 있는 프로그램
- **운영체제로부터 시스템 자원을 할당받는 작업의 단위**
- 운영체제로부터 할당받는 시스템 자원
  - CPU 시간
  - 운영되기 위해 필요한 주소 공간
  - Code, Data, Stack, Heap 구조로 되어있는 독립된 메모리 영역
- **Code** : 코드 자체를 구성하는 메모리 영역(프로그램 명령)
- **Data** : 전역변수, 정적변수, 배열 등 (초기화된 데이터)
- **Heap** : 동적 할당 시 사용 (new(), mallock() 등)
- **Stack** : 지역변수, 매개변수, 리턴 값 (임시 메모리 영역)
- **기본적으로 프로세스당 최소 1개의 스레드(메인 스레드)를 가지고 있다.**
- 각 프로세스는 별도의 주소 공간에서 실행되며, **한 프로세스는 다른 프로세서의 변수나 자료구조에 접근할 수 없다.**
- 프로세스는 **각각 독립된 메모리 영역(Code, Data, Stack, Heap)을 할당**받는다.

<br>

## (2) 스레드

![스레드](https://github.com/jr31112/Prepare-Interview/raw/master/os/process%26thread/thread)

- **프로세스 내부에서 실행되는 작업 흐름 단위**
- 프로세스의 특정한 수행 경로
- 같은 프로세스 안에 있는 여러 스레드들은 **같은 힙 공간을 공유**한다. 반면에 프로세스는 다른 프로세스의 메모리에 직접 접근할 수 없다.
- 각각의 스레드는 별도의 레지스터와 스택을 갖고 있지만, 힙 메모리는 서로 읽고 쓸 수 있다.
- 하나의 프로세스를 여러 개의 스레드로 생성하여 병행성 증진
- 실행 환경을 공유시켜 기억장소 및 자원의 낭비가 줄어듬

<br>

## (3) 멀티 프로세스

- 하나의 컴퓨터에 여러 CPU를 장착하고 하나 이상의 프로세스들을 동시에 처리
- 하나의 응용프로그램을 여러 개의 프로세스로 분리하여 작업 
- 장점
  - 안전성 (메모리 침범 문제를 OS 차원에서 해결)
- 단점
  - context switch으로 인한 성능 저하(프로세스 상태 보관 및 복구 과정에서 추가시간이 걸림)

---

:heavy_check_mark: <b>Context Switch</b>

- 여러 프로세스를 돌아가면서 작업을 처리하는 과정
- 새로운 프로세스에게 CPU를 할당하기 위해 현재 CPU가 할당된 프로세스의 상태 정보를 저장하고, 새로운 프로세스의 상태 정보를 설정한 후 CPU를 할당하여 실행되는 작업
- 프로세스 상에서 Context Switch가 일어나면 이때 작업 중이던 Context를 저장하고 새로운 Context를 불러오면서 CPU 레지스터 상태 변환, 메모리 초기화 등 무거운 작업이 진행되고 많은 시간이 소모되는 오버헤드가 발생한다.(멀티 프로세스의 단점과 연관)
- Context Switch의 비용은 프로세스가 스레드보다 더 많이 든다.
  - 이유 : 스레드는 Stack 영역을 제외한 모든 메모리를 공유하므로 Context Switch 발생시 Stack 영역만 변경을 진행하면 되기 때문이다.

---

<br>

## (4) 멀티 스레드

- 하나의 응용 프로그램에서 여러 스레드를 구성해 각 스레드가 하나의 작업을 처리하는 것
- 기본적으로 하나의 프로세스는 하나의 스레드로 시작되며 이를 메인 스레드라고 하고 스레드를 추가로 생성하지 않는 한 모든 프로그램은 메인 스레드에서 실행된다.
- 일반적인 코드를 구성하는 과정을 생각해보면 json 파일을 불러와서 읽고 내용을 변경한 후 다시 수정된 json 파일을 저장하는 세 가지의 부분과정이 순차적으로 진행되어 각 작업 간 의존관계가 있는 코드들이 대부분일 것이다.
- 이러한 순차적인 방식은 중간과정의 한 부분이 오래걸리면 전체 프로그램 실행 속도가 느려지는 단점이 있다.
- 하지만 모든 작업이 순차적으로만 진행되어야 한다는 법은 없다. 한 프로세스 내에서 서로 순서상 의존하지 않고 다른 작업의 종료를 기다리지 않아도 되는 경우도 존재한다.
- 이 때 실행되는 흐름, 스레드를 여러 개 두면 병목현상에 걸리지 않고 전체 작업시간을 줄일 수 있는데 이를 멀티 스레드라고 한다.
- 장점
  - 시스템의 자원 소모가 줄어든다.
    - 기존 프로세스의 자원을 다른 스레드와 공유하기 때문에 자원을 새로 할당하지 않아도 된다.
  - 전체 응답 시간이 단축된다.
    - 시간도 자원이므로 오버헤드가 줄어들어 전체 응답이 짧아진다.
    - 또한 병목이 걸리는 작업과 다른 작업을 구분할 수 있기 때문에 전체 실행시간을 줄일 수 있다.
- 단점
  - 다른 프로세스에서 스레드를 제어할 수 없다.
  - 하나의 스레드에 문제가 생기면 전체 프로세스가 영향을 받는다.
  - 디버깅이 까다롭다.
  - 자원 공유의 문제가 발생

<br>

## :exclamation: Process VS Thread 비교 정리

| 항목      | Process                                                      | Thread                                                       |
| --------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 실행 방식 | 운영체제로부터 독립된 시간, 공간 자원을 할당 받아 실행       | 한 프로세스 내에서 많은 자원을 공유하며 병렬적으로 실행      |
| 자원 공유 | 일반적으로 공유 안 함. 같은 프로그램의 프로세스인 경우 코드는 공유함 | 같은 프로세스 내 스레드들은 스택을 제외한 나머지 세 영역을 공유 |
| 통신      | 오직 시스템이 제공하는 IPC 방법으로만 통신, 시스템에 의해 관리되므로 상대적으로는 안전하나 스레드간 통신보다 어렵다. | 단순히 공유 변수 수정만으로 스레드간 통신을 구현할 수 있어 통시니 매우 용이하지만 안전한 프로그램을 만들기 위해서는 신중해야 함 |
| 문맥 교환 | Switch 될 때 오버헤드 발생                                   | 더 빠르고 자원소모가 적다.                                   |

<br>

---

:book: <b>Reference</b>

- [https://github.com/WooVictory/Ready-For-Tech-Interview/blob/master/Operating%20System/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80%20%EC%8A%A4%EB%A0%88%EB%93%9C.md](https://github.com/WooVictory/Ready-For-Tech-Interview/blob/master/Operating System/프로세스와 스레드.md)
- https://github.com/wally-wally/tech-interview/blob/master/contents/os.md
- https://shoark7.github.io/programming/knowledge/difference-between-process-and-thread

---

