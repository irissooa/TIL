# 01. TCP & UDP

<br>

## 1. TCP (Transmission Control Protocol)

### (1) TCP란?

인터넷상에서 데이터를 메세지의 형태로 보내기 위해 IP와 함께 사용하는 프로토콜

일반적으로 TCP와 IP를 함께 사용하는데 IP가 데이터의 배달을 처리하면 TCP는 <u>패킷을 추적 및 관리</u>하게 된다.

---

:heavy_check_mark: <b> TCP의 패킷 추적 및 관리 방법</b>

- 패킷이 A, B, C, D와 같은 순서로 발신 노드에서 수신 노드로 전송된다고 가정하자,
- 중간에 C 패킷이 길을 잘못 들어서 분실되었을 때 목적지 수신 노드 측에서는 A, B, C, D가 모두 필요한지 모르고 A, B, D만 보고 모든 패킷이 정상적으로 도착했다고 착각할 수 있다.
- 그래서 이러한 아찔한 상황을 막기 위해 A, B, C, D 패킷에 1, 2, 3, 4라는 번호를 부여해서 수신 노드 측에서는 도착한 패킷들을 재조립하여 패킷의 분실을 막을 수 있다.
- 이러한 방식으로 TCP는 패킷을 추적하며 나누어 보내진 데이터를 받고 조립할 수 있다.

---

<br>

### (2) TCP의 특징

- <b>연결지향(Connection-oriented)</b> : 2개의 호스트가 통신을 하기 전 연결이 이루어져야 한다.
- <b>높은 신뢰성(Reliability)</b> + <b>순서대로 전송하는 것(In-order delivery)</b> 이 두 가지 사항을 보장한다.
  - <b>흐름 제어(Flow Control)</b> : 송신자의 데이터 양을 조절
  - <b>혼잡 제어(Congestion Control)</b> : 네트워크 상황을 감지하고 송신자의 데이터 양을 조절
  - <b>에러 감지(Error detection)</b> : 잘못 전송되었을 경우 재전송하기 때문에 Streaming 서비스에 불리하다.

---

:heavy_check_mark: <b>신뢰성의 의미</b>

- TCP 프로토콜은 신뢰성은 있는 스트림 전송서비스의 제공을 목적으로 한다.
- 이 때 오류 제어 기능이 있을 때 신뢰성이 있다는 의미이다.

---

- <b>가상 회선 방식</b>으로 패킷을 교환한다.

- <b>전이중 방식(Full Duplex)</b> : 두 호스트 모두 송신자와 수신자가 될 수 있다.
- <b>점 대 점 방식(Point to Point)</b>
- <b>바이트 스트림(Byte Stream)</b>을 사용하여 데이터를 연속적인 바이트로 보내고, <b>세그먼트(Segment)</b>라는 단위의 패킷으로 쪼개서 보낸다.

- <b>3- way handshaking 과정을 통해 연결하고 4-way handshaking을 통해 해제한다.</b>
- UDP 보다 속도가 느리다.
- HTTP, FTP, SMTP, TELNET 등에서 사용된다.

<br>

### (3) TCP 서버의 특징

- 서버소켓은 연결만을 담당한다.
- 연결과정에서 반환된 클라이언트 소켓을 데이터의 송수신에 사용되는 서비스 방식으로 가산 회선 방식을 제공한다.
- 서버와 클라이언트는 1대1로 연결된다.
- 스트림 전송으로 전송 데이터의 크기가 무제한이다.
- 패킷에 대한 응답을 해야 하므로 시간 지연, CPU 소모에 의해 성능이 낮다.
- 손실된 경우 재전송 요청을 해야하기 때문에 Streaming 서비스에 불리하다.

<br>

### (4) 3-way handshaking

TCP/IP 프로토콜을 이용하여 통신할 때 두 종단(호스트) 간 정확한 데이터 전송을 보장하기 위해 연결을 설정하는 과정

TCP는 <u>양방향 연결</u>이므로 클라이언트에서 서버에게 자신의 존재를 알리고 패킷을 보낼 수 있는 것처럼 서버에서도 클라이언트에게 자신의 존재를 알리고 패킷을 보낼 수 있다는 신호를 보내야 하므로 2-way가 아닌 <u>3-way</u>가 되는 것이다.

<img src="https://user-images.githubusercontent.com/33534771/75338886-d77ea880-58d2-11ea-84c3-f8b60663f9c6.png" width="60%"/>

- <b>Connection Process</b>
  - 서버는 클라이언트의 연결요청을 기다리고 있다. (`LISTEN`)
  - 클라이언트는 서버에 접속을 요청하는 `SYN`(a) 패킷을 보낸다.
  - 서버는 클라이언트의 요청인 `SYN`(a) 패킷에 대한 요청 수락 응답으로 `ACK`(a+1) 패킷과 클라이언트도 포트를 열어달라는 `SYN`(b) 패킷을 보낸다.
  - 클라이언트는 `ACK`(a+1) 패킷과 `SYN`(b) 패킷을 받고 `ACK` 패킷의 시퀀스 번호를 보고 자신의 보낸 시퀀스 보호와 차이가 1임을 확인한다. 차이가 1이라면 제대로 연결되었다고 판단하고 이에 대한 응답으로 `ACK` 패킷과 서버의 `SYN` 패킷에 있는 시퀀스 번호(b)에 1을 더해 `ACK` 패킷을 담아 보낸다.
  - 서버는 클라이언트의 `ACK` 패킷을 받고 그 안의 시퀀스 번호가 보냈던 `SYN` 패킷의 시퀀스 번호 + 1 이라면 연결되었다고 판단한다. 이후부터 본격적인 통신이 이루어지는 것이다.
- <b>랜덤한 시퀀스 번호(Sequence Number)를 사용하는 이유</b>
  - 처음에 클라이언트에서 서버에 접속을 요청하는 `SYN` 패킷을 보낼 때 랜덤한 Sequence Number도 함께 담아서 보낸다.
  - 연결을 맺을 때, 사용하는 포트는 유한 범위 내에서 사용하고 시간이 지남에 따라 재사용한다. 따라서 이전에 사용한 포트 번호를 재사용할 가능성이 있다.
  - Sequence Number가 순차적인 숫자로 전송된다면 서버는 이전의 연결로부터 전송되는 패킷으로 인식할 수 있다.
  - 따라서 이러한 문제를 해결하기 위해 랜덤한 값으로 Sequence Number를 사용하는 것이다.

<br>

### (5) 4-way handshaking

<img src="https://user-images.githubusercontent.com/33534771/75338959-ef562c80-58d2-11ea-99eb-1c09ec97e83a.png" width="60%"/>

TCP/IP 프로토콜을 이용한 통신 과정에서는 3-way handshaking 과정을 통해 연결을 설정하고 4-way-handshaking 과정을 통해 연결을 해제한다. 자세한 연결 프로세스를 살펴보자.

- <b>Connection Process</b>
  - 클라이언트가 연결을 종료하겠다는 `FIN` 패킷을 서버측으로 전송한다.
  - 서버는 클라이언트에서 보낸 `FIN` 패킷을 받고 요청 수락 응답으로 `ACK` 패킷을 클라이언트 측으로 보낸다. 그리고 나서 데이터를 모두 보낼 때까지 잠깐 <b>TIME_OUT</b>이 된다.
  - 데이터를 모두 보낸 후 통신이 끝나면 연결이 종료되었다고 클라이언트에게 `FIN` 패킷을 전송한다.
  - 클라이언트는 `FIN` 패킷을 받았다는 `ACK` 패킷을 서버 측으로 보낸다.
  - 클라이언트의 `ACK` 패킷을 받은 서버는 소켓 연결을 해제한다.
  - 클라이언트는 아직 서버로부터 받지 못한 데이터가 있을 것을 대비해 일정 시간 동안 세션을 남겨 놓고 잉여 패킷을 기다리는 과정을 거친다.(<b>TIME_WAIT</b>)
- <b>연결 종료과정에서 에러가 발생하는 경우</b>
  - 클라이언트에서 `FIN` 패킷 전송 후 `ACK` 패킷을 기다리는 `FIN_WAIT1`과 서버의 `ACK` 패킷을 받은 후 `FIN` 패킷을 기다리는 `FIN_WAIT2` 에서 에러 발생으로 인해 Time out이 되면 스스로 연결을 종료한다.

  - 그러나, CLOSE_WAIT은 Application이 close()를 적절하게 처리하지 못하면 CLOSE_WAIT 상태로 계속 기다리게 되어 Socket Hang Up 에러가 발생할 수 있다.

<br>

## 2. UDP (User Datagram Protocol)

데이터를 데이터그램 단위로 처리하는 프로토콜

여기서 데이터그램이란 독립적인 관계를 지니는 패킷이다.

<br>

### (1) UDP의 특징

- TCP와 달리 데이터의 <b>신뢰성을 보장하지 않는</b> 프로토콜이다.
- <b>비연결형(Connection-less)</b> : 별도의 연결을 설정하고 해제하는 과정이 없다.
- <b>신뢰성이 없고</b> 전송되는 <b>데이터의 순서를 보장하지 않는다.</b>
  - 흐름 제어, 혼잡 제어가 없다. 그렇기 때문에 패킷이 제대로 전송되었는지 오류가 없는지 확인할 수 없다.
  - 에러 감지는 헤더의 체크섬(checksum)을 이용한 정도 밖에 없다.

---

:heavy_check_mark: <b>헤더 체크섬</b>

- CRC 코드와 같은 헤더 체크섬은 헤더의 오류만 검출하는 역할을 한다.
- 데이터 부분의 오류 체크는 헤더 체크섬이 하지 않고 수송 계층으로 보내서 그쪽에서 오류를 체크하도록 수행한다.

---

- <b>데이터그램 방식</b>로 패킷을 교환한다.

- 패킷의 단위가 <b>데이터그램(Datagram)</b>으로 <b>경계가 분명</b>하여 수신자는 송신자가 보낸 그대로의 크기로 받게 된다.
- TCP에 비해서 하는 작업들이 굉장히 작으므로 <b>속도가 빠르다.</b>
- 정보를 주고 받을 때 정보를 보내거나 받는다는 신호절차를 거치지 않는다.
- DNS, DHCP, 비디오/오디오 스트리밍 등에 사용된다.

<br>

### (2) UDP 서버의 특징

- UDP에는 연결 자체가 없어서(`connect` 함수 불필요) 서버 소켓과 클라이언트 소켓의 구분이 없다.
- 소켓 대신 IP를 기반으로 데이터를 전송한다.
- 서버와 클라이언트는 유니캐스트(1:1), 브로드캐스트(1:N), 멀티캐스트(1:M)가 가능하다.
  - 이 때 N은 전체, M은 일부
- <b>데이터그램(메세지) 단위로 전송</b>되며 그 크기는 65535바이트로, 크기가 초과하면 잘라서 보낸다.
- 파일 전송과 같은 신뢰성이 필요한 서비스보다 성능이 중요시 되는 경우에 사용된다.

<br>

## 3. TCP & UDP 정리

- TCP : 연속성보다는 <b><u>신뢰성</u></b> 있는 전송이 중요할 때 사용하는 프로토콜
- UDP : 신뢰성보다는 <b><u>연속성</u></b>이 중요할 때 사용하는 프로토콜

| 프로토콜 종류  | TCP              | UDP                      |
| -------------- | ---------------- | ------------------------ |
| 연결 방식      | 연결형 서비스    | 비연결형 서비스          |
| 패킷 교환 방식 | 가상 회선 방식   | 데이터그램 방식          |
| 전송 순서      | 전송 순서 보장   | 전송 순서가 바뀔 수 있음 |
| 수신 여부 확인 | 수신 여부 확인 O | 수신 여부 확인 X         |
| 통신 방식      | 1:1 통신         | 1:1 or 1:N or 1:M 통신   |
| 신뢰성         | 높다             | 낮다                     |
| 속도           | 느리다           | 빠르다                   |

<br>

## 4. 흐름 제어 & 혼잡 제어

### (1) 흐름 제어(Flow Control)

- <b>전송 스테이션으로부터 전송 데이터의 양을 제한하기 위해서 사용되는 절차</b>
- 데이터를 송신하는 곳과 수신하는 곳의 데이터 처리 속도를 조절하여 수신자의 버퍼 오버플로우를 방지하는 것
- 송신하는 곳에서 감당이 안 되게 데이터를 빠르게 많이 보내면 수신자에서 문제가 발생할 수 있기 때문
- `Stop and Wait` 기법
  - <b>매번 전송한 패킷에 대한 확인 응답을 받아야 그 다음 패킷을 전송할 수 있다.</b>
  - 구조가 간단하다는 장점이 있지만 하나의 프레임을 보내고 `ACK` 패킷이 수신되어야만 그 다음 프레임을 전송할 수 있기 때문에 비효율적이다.
- `Sliding Window` 기법
  - 윈도우(Window) : 전송 및 수신 스테이션 양쪽에서 만들어진 버퍼(buffer)의 크기
  - 전송한 프레임에 대한 `ACK` 패킷을 수신하지 않더라도, 여러 개의 프레임을 연속적으로 전송하도록 허용하여 `Stop and Wait` 기법의 효율성을 개선한 방법
  - <b>수신측에서 설정한 윈도우 크기만큼 송신측에서 확인, 응답 없이 세그먼트를 전송할 수 있게 하여 데이터 흐름을 동적으로 조절하는 기법</b>

<br>

### (2) 혼잡 제어(Congestion Control)

- <b>송신측의 데이터 전달과 네트워크 데이터처리 속도 차이를 해결하기 위한 기법</b>

- 한 라우터에게 데이터가 몰려 모든 데이터를 처리할 수 없는 경우, 호스트들은 재전송을 하게 되고 결국 혼잡만 가중시켜 오버플로우나 데이터 손실이 발생한다.

- 이러한 **네트워크의 혼잡을 피하기 위해 송신측에서 보내는 데이터의 전송 속도를 제어**하는 것이 혼잡 제어의 개념이다.

- 네트워크의 혼잡을 피하기 위해 송신측에서 보낸 데이터의 전송 속도를 강제로 줄이는 방법 중 `Slow Start`에 대해 간략히 살펴보자.

  - 패킷이 문제 없이 도착하면 각각의 `ACK` 패킷마다 윈도우 크기를 1씩 늘린다. 즉, 한 주기가 지나면 윈도우 크기는 2배가 된다.
  - 윈도우 크기를 2배 늘리고 혼잡현상이 발생하면 1로 떨어뜨린다. 그 후 혼잡현상이 발생했던 윈도우 크기는 절반까지는 이전처럼 지수 함수 꼴로 윈도우 크기를 증가한다.
  - Slow Start라는 이름을 사용하지만, 매 전송마다 2배씩 증가하기 때문에 전송되어지는 데이터의 크기는 지수함수적으로 증가한다.
  - 전송되는 데이터의 크기가 임계 값에 도달하면 혼잡 회피 단계로 넘어간다.

  <img src="https://user-images.githubusercontent.com/33534771/75339370-bb2f3b80-58d3-11ea-9211-af3ca1e5960b.png" width="500px">

  - 혼잡 회피(Congestion Avoidance) : 윈도우의 크기가 임계 값에 도달한 이후에는 데이터의 손실이 발생할 확률이 높아진다. 따라서 이를 회피하기 위해 <b>윈도우 크기를 선형적으로 1씩 증가시키는다.</b>
  - 빠른 회복(Fast Recovery) : 혼잡한 상태가 되면 윈도우 크기를 1로 줄이지 않고 반으로 줄이고 선형 증가시키는 방식이다.

<br>

---

:book: <b>Reference</b>

- https://mangkyu.tistory.com/15
- https://jsonsang2.tistory.com/17
- https://asfirstalways.tistory.com/356
- https://github.com/WooVictory/Ready-For-Tech-Interview/blob/master/Network/TCP.md